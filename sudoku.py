import os
import random
from collections import deque

import pygame

import ptext
from common import Button

LIGHT_GREEN = (86, 232, 105)
DARK_GREEN = (76, 133, 83)
ORANGE = (255, 180, 0)
RED = (255, 0, 0)  # hard/insane
DARK_RED = (143, 3, 3)
GREY = (143, 156, 145)
SHADED_BLUE = (80, 90, 133)
BROWN = (168, 109, 50)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
YELLOW = (209, 252, 15)
AQUATIC_BLUE = (48, 209, 204)

QUIT_GAME = "quite"
PLAY_AGAIN = "play_again"
CHANGE_DIFFICULTY = "cdiff"
INFO_PAGE = "info"
HOME_PAGE = "home"

# The button can be styled in a manner similar to CSS.
BUTTON_STYLE = {
    "hover_color": SHADED_BLUE,
    "clicked_color": BLUE,
    "clicked_font_color": BLACK,
    "hover_font_color": WHITE,
}

# os.environ["SDL_VIDEO_CENTERED"] = '1'
os.environ['SDL_VIDEO_WINDOW_POS'] = "1"
# os.environ['SDL_VIDEO_WINDOW_POS'] = "%d,%d" % (900, 400)  # For testing, usually it's always in the way of my code
# os.environ["PYGAME_HIDE_SUPPORT_PROMPT"] = '1'  # Export outside of this script

VERY_EASY = "Very Easy"
EASY = "Easy"
MEDIUM = "Medium"
INSANE = "Insane"
INSANELY_EVIL = "Insanely Evil"

difficulties = {
    "Very Easy": random.randint(50, 60),
    "Easy": random.randint(36, 49),
    "Medium": random.randint(32, 35),
    "Insane": random.randint(28, 31),
    "Insanely Evil": random.randint(22, 27),
}


class Board(object):

    def __init__(self, width, height, window, difficulty=None):
        self.POSITIONS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
                          71, 72, 73, 74, 75, 76, 77, 78, 79, 80]
        self.difficulty = difficulty
        self.width = width
        self.height = height
        self.window = window
        self.rows = 9
        self.cols = 9
        self.selected = None
        self.key_pressed = None
        self.board = []
        self.generate_board()

        self.d_boxes = []
        for i in range(self.rows):
            b_cols = []
            for j in range(self.cols):
                d_box = DigitBox(self.board[i][j], i, j, width, height, self.window)
                b_cols.append(d_box)
            self.d_boxes.append(b_cols)

        self.board_model = None
        self.update_model()

    def update_model(self):
        """
            This updates the model of the boxes, e.g. the track keeper (DB sort-of)
            This model is used to check if the digit the user enters, is allowed to be entered
        """
        self.board = [[self.d_boxes[i][j].value for j in range(self.cols)] for i in range(self.rows)]

    def generate_board(self):
        """
        The board is generated by shifting the rows by 033,133,133
            l1: 8 9 3  2 7 6  4 5 1
            l2: 2 7 6  4 5 1  8 9 3 (shift 3)
            l3: 4 5 1  8 9 3  2 7 6 (shift 3)

            l4: 5 1 8  9 3 2  7 6 4 (shift 1)
            l5: 9 3 2  7 6 4  5 1 8 (shift 3)
            l6: 7 6 4  5 1 8  9 3 2 (shift 3)

            l7: 6 4 5  1 8 9  3 2 7 (shift 1)
            l8: 1 8 9  3 2 7  6 4 5 (shift 3)
            l9: 3 2 7  6 4 5  1 8 9 (shift 3)
        """
        inital_row = deque([])
        while len(inital_row) < 9:
            new_int = random.randint(1, 9)
            if new_int in inital_row:
                continue
            inital_row.append(new_int)

        self.board.append(list(inital_row))
        shift_scale = [3, 3, 1, 3, 3, 1, 3, 3]
        for shift_int in shift_scale:
            inital_row.rotate(shift_int)
            self.board.append(list(inital_row))

        levels = 81 - difficulties.get(self.difficulty, 50)
        for _ in range(levels):
            pos = str(random.choice(self.POSITIONS))
            y = int(pos[0]) if pos[0] != '9' else 8
            x = ((int(pos[1]) - 1) if pos[1] == '9' else int(pos[1])) if pos[-1] != pos[0] else 0  # need to exclude 9 if we using int 81
            self.board[y][x] = 0
            self.POSITIONS.remove(int(pos))

    def can_solve(self):  # Quick solve, which does not change the gui
        empty_slot = self.locate_empty_slot()
        if not empty_slot:
            return True
        y, x = empty_slot
        for z in range(1, 10):
            if self.is_possible(x, y, z):
                self.board[y][x] = z
                if self.can_solve():
                    return True
                self.board[y][x] = 0
        return False  # No possible solutions with Existing numbers on self.board

    def solve_game(self):
        """
            Does Recursion on itself until all solutions are found
            or no possible solution is found, in that case return False
        """
        empty_slot = self.locate_empty_slot()
        if not empty_slot:
            return True
        y, x = empty_slot
        for z in range(1, 10):
            if self.is_possible(x, y, z):
                self.board[y][x] = z
                self.d_boxes[y][x].set_value(z)
                self.d_boxes[y][x].update()
                self.update_model()
                pygame.display.update()
                pygame.time.delay(100)

                if self.solve_game():
                    return True

                self.board[y][x] = 0  # Set virtual board to none
                self.d_boxes[y][x].set_value(0)
                self.update_model()
                self.d_boxes[y][x].update(error=True)
                pygame.display.update()
                pygame.time.delay(100)

        return False  # No possible solutions with Existing numbers on self.board

    def is_possible(self, x, y, num):
        """
            :param x:
            :param y:
            :param num:  The number that needs to be verified for placement
            :return: False or True (depending on whether :param num: is allowed)
        """

        for i in range(9):
            if self.board[i][x] == num:
                return False
            if self.board[y][i] == num:
                return False

        # Formula for below
        # (x // 3) * 3  -> will give the start point of each section
        # The loop will then increment and check each block in that section
        x_block = (x // 3) * 3
        y_block = (y // 3) * 3
        for i in range(3):
            for z in range(3):
                if self.board[y_block + i][x_block + z] == num:
                    return False
        return True

    def locate_empty_slot(self):
        for i in range(9):
            for z in range(9):
                if self.board[i][z] == 0:
                    return i, z
        return None

    def draw_board(self):
        """
            Draws the board in which the game is played
        """
        self.window.fill(LIGHT_GREEN)
        # Draw the board lines
        mini_block_width = self.width / 9
        for i in range(self.rows + 1):
            line_width = 4 if (i % 3 == 0 and i != 0) else 1
            line_point = int(i * mini_block_width)
            pygame.draw.line(self.window, BLACK, (0, line_point), (int(self.width), line_point), line_width)
            pygame.draw.line(self.window, BLACK, (line_point, 0), (line_point, int(self.height)), line_width)

        # Draw the rect digit blocks
        for y in range(self.rows):
            for x in range(self.cols):
                self.d_boxes[y][x].construct()

    def clear(self):
        """Sets item to 0 using x,y from self.selected"""
        row, col = self.selected
        if self.d_boxes[row][col].value == 0:
            self.d_boxes[row][col].set_temp(0)

    def has_clicked_in_box(self, area):
        """Checks if the click was in one of the boxes :position: (x, y)"""
        x_width = area[0]
        y_width = area[1]
        if x_width < self.width and y_width < self.height:
            single_block_width = self.width / 9
            x = x_width // single_block_width  # e.g. 30/ 10 -> 3 -> block 3
            y = y_width // single_block_width
            return y, x

        return False

    def select_block(self, y, x):
        for i in range(9):
            for z in range(9):
                self.d_boxes[i][z].selected = False

        self.d_boxes[y][x].selected = True
        self.selected = (y, x)

    def sketch(self):
        row, col = self.selected
        self.d_boxes[row][col].set_temp(self.key_pressed)

    def write_number_to_board(self, num):
        y, x = self.selected
        if self.d_boxes[y][x].value == 0:
            self.d_boxes[y][x].set_value(num)
            if self.is_possible(x, y, num) and self.can_solve():
                self.update_model()
                return True
            else:
                self.d_boxes[y][x].set_value(0)
                self.d_boxes[y][x].set_temp(0)
                self.update_model()
                return False

    def check_events(self, button_exit, button_autocomplete, button_reset_difficulty, button_play_again):
        for event in pygame.event.get():

            if button_reset_difficulty.check_event(event):
                return CHANGE_DIFFICULTY

            if button_play_again.check_event(event):
                return PLAY_AGAIN

            if button_exit.check_event(event):
                return QUIT_GAME

            if button_autocomplete.check_event(event):
                self.solve_game()

            if event.type == pygame.KEYDOWN:
                if event.key in [pygame.K_RETURN, pygame.K_KP_ENTER]:
                    i, j = self.selected
                    if self.d_boxes[i][j].temp:  # checks if a temp exists, if not a number probably already exists there
                        self.write_number_to_board(self.d_boxes[i][j].temp)
                        self.key_pressed = None

                        if self.is_completed():
                            # TODO move the screen to a success you completed the game screen,
                            #  with play again button and reset difficulty button
                            print("Game over")

                if event.key in [pygame.K_1, pygame.K_KP1]:
                    self.key_pressed = 1
                elif event.key in [pygame.K_2, pygame.K_KP2]:
                    self.key_pressed = 2
                elif event.key in [pygame.K_3, pygame.K_KP3]:
                    self.key_pressed = 3
                elif event.key in [pygame.K_4, pygame.K_KP4]:
                    self.key_pressed = 4
                elif event.key in [pygame.K_5, pygame.K_KP5]:
                    self.key_pressed = 5
                elif event.key in [pygame.K_6, pygame.K_KP6]:
                    self.key_pressed = 6
                elif event.key in [pygame.K_7, pygame.K_KP7]:
                    self.key_pressed = 7
                elif event.key in [pygame.K_8, pygame.K_KP8]:
                    self.key_pressed = 8
                elif event.key in [pygame.K_9, pygame.K_KP9]:
                    self.key_pressed = 9
                elif event.key == pygame.K_DELETE:
                    self.clear()
                    self.key_pressed = None

            if event.type == pygame.MOUSEBUTTONDOWN:
                position = pygame.mouse.get_pos()
                has_clicked = self.has_clicked_in_box(position)
                if has_clicked:
                    self.select_block(int(has_clicked[0]), int(has_clicked[1]))
                    self.key_pressed = None

            if self.selected and self.key_pressed is not None:
                self.sketch()

        return True  # returning true as we do not want to exit game

    def is_completed(self):
        for i in range(9):
            for z in range(9):
                if self.board[i][z] == 0:
                    return False
        return True


class DigitBox(object):
    def __init__(self, value, x, y, width, height, window):
        self.window = window
        self.value = value
        self.temp = 0
        self.row = x
        self.column = y
        self.width = width
        self.height = height
        self.selected = False
        self.block_width = width / 9

    def construct(self):
        block_size = self.width / 9
        x = self.column * block_size
        y = self.row * block_size

        font = pygame.font.SysFont("", 45)
        if self.value:
            text = font.render(str(self.value), 1, BLACK)
            self.place_center(text, x, y)
        elif self.temp:
            text = font.render(str(self.temp), 1, SHADED_BLUE)
            self.window.blit(text, (int(x + 5), int(y + 6)))

        if self.selected:
            pygame.draw.rect(self.window, RED, (int(x), int(y), int(block_size), int(block_size)), 3)

    def update(self, error=False):
        """
            This function place the number on the board
            :param error: if it a error display error border on block
        """
        font = pygame.font.SysFont("", 45, bold=True)
        x = self.column * self.block_width
        y = self.row * self.block_width

        pygame.draw.rect(self.window, DARK_GREEN, (int(x), int(y), int(self.block_width), int(self.block_width)))
        text = font.render(str(self.value), 1, BLACK)
        self.place_center(text, x, y)

        if error:  # Solution is not possible, Outline the box in red
            pygame.draw.rect(self.window, RED, (x, y, self.block_width, self.block_width), 3)
        else:  # Solution is possible, outline in yellow
            pygame.draw.rect(self.window, YELLOW, (x, y, self.block_width, self.block_width), 3)

    def place_center(self, text, x, y):
        self.window.blit(text, (int(x + (self.block_width / 2 - text.get_width() / 2)), int(y + (self.block_width / 2 - text.get_height() / 2))))

    def set_value(self, value):
        self.value = value

    def set_temp(self, value):
        self.temp = value


class Main(object):

    def __init__(self):
        pygame.display.set_caption("Sudoku")
        self.main_window_height = 640
        self.main_window_width = 540
        self.window = pygame.display.set_mode((self.main_window_width, self.main_window_height))
        self.win_rect = self.window.get_rect()

        self.difficulty = None
        self.home_scene_active = True
        self.game_scene_active = False
        self.info_scene_active = False
        self.autocomplete_board = False
        self.in_loop = True

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        pygame.quit()

    def run_loop(self):

        while self.in_loop:
            if self.homemenu_scene() is False:
                return

            if self.game_scene() is False:
                return

            if self.info_scene() is False:
                return

    def info_scene(self):
        self.window.fill(WHITE)
        font = pygame.font.SysFont("", 50)
        head_text = font.render("HOW TO PLAY SUDOKU", 4, BLACK)

        button_exit = Button((18, 580, 250, 50), AQUATIC_BLUE, self.quite_game, text="Quit Game", **BUTTON_STYLE)
        button_home = Button((275, 580, 250, 50), BROWN, self.home_page, text="Home Page", **BUTTON_STYLE)
        buttons = (button_home, button_exit)

        point1 = "In a single vertical row, only 1-9\ndigits may be entered with no\nduplicates."
        point2 = "In a single horizontal row, only\n1-9 digits may be entered with no\nduplicates"
        point3 = "In a container block (3x3), only\n1-9 digits may be entered with no\nduplicates"
        point4 = "To add a number to the board, click\non a block, then enter a digit\nusing the keyboard, when you are\nconfident it's correct, hit enter. If it was wrong, the number will disappear else it commit it to the board."
        self.draw_borders()
        pygame.draw.circle(self.window, BLACK, (25, 150), 6, 6)
        pygame.draw.circle(self.window, BLACK, (25, 250), 6, 6)
        pygame.draw.circle(self.window, BLACK, (25, 350), 6, 6)
        pygame.draw.circle(self.window, BLACK, (25, 450), 6, 6)
        while self.info_scene_active:
            pygame.time.wait(200)
            self.window.blit(head_text, (75, 50))
            ptext.draw(point1, (48, 125), color=BLUE, sysfontname="mono")
            ptext.draw(point2, (48, 225), color=BLUE, sysfontname="mono")
            ptext.draw(point3, (48, 325), color=BLUE, sysfontname="mono")
            ptext.draw(point4, (48, 425), color=BLUE, sysfontname="mono")

            for event in pygame.event.get():
                for button in buttons:
                    if button_result := button.check_event(event):
                        if button_result == QUIT_GAME:
                            return False
                        elif button_result == HOME_PAGE:
                            self.home_scene_active = True
                            self.game_scene_active = False
                            self.info_scene_active = False
                            return

            for button in buttons:
                button.update(self.window)  # Button effects like on hover, and adding border
            self.update_display()

    def game_scene(self):
        board = Board(540, 540, self.window, self.difficulty)
        self.window.fill(LIGHT_GREEN)
        button_exit_size = (10, (self.main_window_height - 45), 250, 40)
        button_ac_size = (10, (self.main_window_height - 90), 250, 40)
        button_reset = (278, (self.main_window_height - 90), 250, 40)
        button_play = (278, (self.main_window_height - 45), 250, 40)

        button_exit = Button(button_exit_size, DARK_RED, self.quite_game, text="Quit Game", **BUTTON_STYLE)
        button_autocomplete = Button(button_ac_size, BLUE, self.run_autocomplete, text="Auto Complete Game", **BUTTON_STYLE)
        button_reset_difficulty = Button(button_reset, AQUATIC_BLUE, self.change_difficulty, text="Reset Difficulty", **BUTTON_STYLE)
        button_play_again = Button(button_play, BROWN, self.play_again, text="Play Again", **BUTTON_STYLE)

        while self.game_scene_active:
            pygame.time.wait(200)  # Slow down CPU Usage
            event_result = board.check_events(button_exit, button_autocomplete, button_reset_difficulty, button_play_again)
            if not event_result or event_result == QUIT_GAME:
                return False

            if event_result == PLAY_AGAIN:
                board = Board(540, 540, self.window, self.difficulty)

            elif event_result == CHANGE_DIFFICULTY:
                self.game_scene_active = False
                self.info_page_active = False
                self.home_scene_active = True

            board.draw_board()
            button_exit.update(self.window)
            button_autocomplete.update(self.window)
            button_reset_difficulty.update(self.window)
            button_play_again.update(self.window)
            self.update_display()

    def homemenu_scene(self):
        self.window.fill(WHITE)
        button_size = (0, 0, 300, 50)
        button_e = Button(button_size, LIGHT_GREEN, self.set_difficulty_very_easy, text="Very Easy", **BUTTON_STYLE)
        button_e.rect.center = (self.win_rect.centerx, 200)
        button_ve = Button(button_size, DARK_GREEN, self.set_difficulty_easy, text="Easy", **BUTTON_STYLE)
        button_ve.rect.center = (self.win_rect.centerx, 275)
        buttom_m = Button(button_size, ORANGE, self.set_difficulty_medium, text="Medium", **BUTTON_STYLE)
        buttom_m.rect.center = (self.win_rect.centerx, 350)
        buttom_i = Button(button_size, RED, self.set_difficulty_insane, text="Insane", **BUTTON_STYLE)
        buttom_i.rect.center = (self.win_rect.centerx, 425)
        buttom_ie = Button(button_size, DARK_RED, self.set_difficulty_insanely_evil, text="Insanely Evil", **BUTTON_STYLE)
        buttom_ie.rect.center = (self.win_rect.centerx, 500)
        button_exit = Button((18, 580, 250, 50), AQUATIC_BLUE, self.quite_game, text="Quit Game", **BUTTON_STYLE)
        button_info = Button((275, 580, 250, 50), BROWN, self.info_page, text="How To Play", **BUTTON_STYLE)

        font = pygame.font.SysFont("", 50)
        text = font.render("SUDOKU THE GAME", 4, BLACK)
        buttons = (button_e, button_ve, buttom_m, buttom_i, buttom_ie, button_exit, button_info)
        self.draw_borders()
        while self.home_scene_active:
            pygame.time.wait(200)
            self.window.blit(text, (100, 50))

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    return False

                for button in buttons:
                    if button_result := button.check_event(event):
                        if button_result == QUIT_GAME:
                            return False
                        elif button_result == INFO_PAGE:
                            self.home_scene_active = False
                            self.game_scene_active = False
                            self.info_scene_active = True
                            return

            for button in buttons:
                button.update(self.window)  # Button effects like on hover, and adding border
            self.update_display()
        self.game_scene_active = True

    def draw_borders(self):
        pygame.draw.line(self.window, BLACK, (0, 570), (540, 570), 4)
        pygame.draw.line(self.window, BLACK, (0, 100), (540, 100), 4)

    def change_difficulty(self):
        return True

    def home_page(self):
        return HOME_PAGE

    def info_page(self):
        return INFO_PAGE

    def quite_game(self):
        return QUIT_GAME

    def play_again(self):
        return True

    def run_autocomplete(self):
        return True

    def set_difficulty_very_easy(self):
        self.difficulty = VERY_EASY
        self.home_scene_active = False

    def set_difficulty_easy(self):
        self.difficulty = EASY
        self.home_scene_active = False

    def set_difficulty_medium(self):
        self.difficulty = MEDIUM
        self.home_scene_active = False

    def set_difficulty_insane(self):
        self.difficulty = INSANE
        self.home_scene_active = False

    def set_difficulty_insanely_evil(self):
        self.difficulty = INSANELY_EVIL
        self.home_scene_active = False

    def update_display(self):
        pygame.display.update()


if "__main__" == __name__:
    pygame.init()

    with Main() as main:  # With, is probably not needed, but it's here anyway
        main.run_loop()
